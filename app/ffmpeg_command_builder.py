# ffmpeg_command_builder.py
import os
import json
import subprocess
from pathlib import Path
from config import FFMPEG_LOG_LEVEL, logger
from typing import Optional


class FFmpegCommandBuilder:
    """
    # G√©n√©rateur de commandes FFmpeg optimis√©es
    # Adapte les param√®tres selon le type de fichier, la pr√©sence de GPU, etc.
    """

    def __init__(self, channel_name, use_gpu=False):
        self.channel_name = channel_name
        self.use_gpu = use_gpu

        # Param√®tres par d√©faut
        self.hls_time = 2
        self.hls_list_size = 20
        self.hls_delete_threshold = 1
        self.gop_size = 48
        self.keyint_min = 48
        self.video_bitrate = "5M"
        self.max_bitrate = "5M"
        self.buffer_size = "10M"

    def build_command(
        self,
        input_file,
        output_dir,
        playback_offset=0,
        progress_file=None,
        has_mkv=False,
    ):
        """Construit la commande FFmpeg compl√®te"""
        try:
            logger.info(
                f"[{self.channel_name}] üõ†Ô∏è Construction de la commande FFmpeg..."
            )

            # Construction de la commande optimis√©e
            command = [
                "ffmpeg",
                "-hide_banner",
                "-loglevel", "info",
                "-y",
                # Param√®tres d'entr√©e optimis√©s
                "-thread_queue_size", "4096",  # R√©duit pour plus de stabilit√©
                "-analyzeduration", "5M",      # R√©duit pour un d√©marrage plus rapide
                "-probesize", "5M",            # R√©duit pour un d√©marrage plus rapide
                "-re",  # Lecture en temps r√©el
                "-fflags", "+genpts+igndts+discardcorrupt",  # Simplifi√©
                "-threads", "2",               # R√©duit pour plus de stabilit√©
                "-avoid_negative_ts", "make_zero",
            ]

            # Ajouter le fichier de progression si fourni
            if progress_file:
                command.extend(["-progress", str(progress_file)])

            # Ajouter l'input
            command.extend(["-i", str(input_file)])

            # Param√®tres de copie optimis√©s
            command.extend([
                "-c:v", "copy",
                "-c:a", "copy",
                "-sn", "-dn",
                "-map", "0:v:0",
                "-map", "0:a:0?",
                "-max_muxing_queue_size", "2048",  # R√©duit pour plus de stabilit√©
                "-fps_mode", "passthrough",
            ])

            # Param√®tres HLS optimis√©s
            command.extend([
                "-f", "hls",
                "-hls_time", "2",
                "-hls_list_size", "6",        # R√©duit pour plus de stabilit√©
                "-hls_delete_threshold", "1",  # R√©duit pour plus de stabilit√©
                "-hls_flags", "delete_segments+append_list+independent_segments",  # Simplifi√©
                "-hls_allow_cache", "1",
                "-start_number", "0",
                "-hls_segment_type", "mpegts",
                "-max_delay", "1000000",       # R√©duit pour plus de stabilit√©
                "-hls_init_time", "1",
                "-hls_segment_filename", f"{output_dir}/segment_%d.ts",
                f"{output_dir}/playlist.m3u8"
            ])

            # Log de la commande compl√®te
            logger.info("=" * 80)
            logger.info(f"[{self.channel_name}] üöÄ Lancement de la commande FFmpeg:")
            logger.info(f"$ {' '.join(command)}")
            logger.info("=" * 80)

            return command
        except Exception as e:
            logger.error(f"[{self.channel_name}] ‚ùå Erreur construction commande: {e}")
            # Fallback √† une commande minimale en cas d'erreur
            return self.build_fallback_command(input_file, output_dir)

    def _rename_all_videos_simple(self):
        """Renomme tous les fichiers probl√©matiques avec des noms ultra simples"""
        try:
            processed_dir = Path(CONTENT_DIR) / self.name / "processed"
            if not processed_dir.exists():
                processed_dir.mkdir(parents=True, exist_ok=True)

            source_dir = Path(CONTENT_DIR) / self.name

            # D'abord, on traite les fichiers sources
            for i, video in enumerate(source_dir.glob("*.mp4")):
                if any(c in video.name for c in " ,;'\"()[]{}=+^%$#@!&~`|<>?"):
                    simple_name = f"video_{i+1}.mp4"
                    new_path = video.parent / simple_name
                    try:
                        video.rename(new_path)
                        logger.info(
                            f"[{self.name}] Source renomm√©: {video.name} -> {simple_name}"
                        )
                    except Exception as e:
                        logger.error(
                            f"[{self.name}] Erreur renommage source {video.name}: {e}"
                        )

            # Ensuite, on traite les fichiers du dossier processed
            for i, video in enumerate(processed_dir.glob("*.mp4")):
                if any(c in video.name for c in " ,;'\"()[]{}=+^%$#@!&~`|<>?"):
                    simple_name = f"processed_{i+1}.mp4"
                    new_path = video.parent / simple_name
                    try:
                        video.rename(new_path)
                        logger.info(
                            f"[{self.name}] Processed renomm√©: {video.name} -> {simple_name}"
                        )
                    except Exception as e:
                        logger.error(
                            f"[{self.name}] Erreur renommage processed {video.name}: {e}"
                        )

        except Exception as e:
            logger.error(f"[{self.name}] Erreur renommage global: {e}")

    def build_input_params(self, input_file, playback_offset=0, progress_file=None):
        """Construit les param√®tres d'entr√©e avec positionnement pr√©cis"""
        params = ["ffmpeg", "-hide_banner", "-loglevel", FFMPEG_LOG_LEVEL, "-y"]

        # Param√®tres de buffer optimis√©s pour r√©duire le buffering
        params.extend(
            [
                "-thread_queue_size",
                "1024",  # R√©duit pour moins de latence
                "-analyzeduration",
                "5M",  # R√©duit pour un d√©marrage plus rapide
                "-probesize",
                "5M",  # R√©duit pour un d√©marrage plus rapide
            ]
        )

        params.extend(
            [
                "-re",  # Lecture en temps r√©el
                "-fflags",
                "+genpts+igndts+discardcorrupt+autobsf",
                "-threads",
                "2",  # R√©duit pour plus de stabilit√©
                "-avoid_negative_ts",
                "make_zero",
            ]
        )

        if progress_file:
            params.extend(["-progress", str(progress_file)])

        params.extend(["-f", "concat", "-safe", "0", "-i", str(input_file)])

        return params

    def build_hls_params(self, output_dir):
        """
        Construit des param√®tres HLS optimis√©s pour une lecture fluide sans boucles
        """
        return [
            "-f",
            "hls",
            "-hls_time",
            "1",  # R√©duit pour moins de latence
            "-hls_list_size",
            "5",  # R√©duit pour moins de latence
            "-hls_delete_threshold",
            "1",  # R√©duit pour moins de latence
            "-hls_flags",
            "delete_segments+append_list+independent_segments+omit_endlist+discont_start+program_date_time",
            "-hls_allow_cache",
            "0",  # D√©sactiv√© pour moins de latence
            "-start_number",
            "0",
            "-hls_segment_type",
            "mpegts",
            "-max_delay",
            "500000",  # R√©duit pour moins de latence
            "-hls_init_time",
            "0.5",  # R√©duit pour g√©n√©rer la playlist plus rapidement
            "-hls_segment_filename",
            f"{output_dir}/segment_%d.ts",
            f"{output_dir}/playlist.m3u8",
        ]

    def build_encoding_params(self, has_mkv=False):
        """Construit les param√®tres d'encodage optimis√©s pour la copie directe"""
        logger.info(
            f"[{self.channel_name}] üìº Param√®tres optimis√©s pour la copie directe"
        )

        # Par d√©faut, on privil√©gie la copie directe avec des param√®tres optimis√©s
        params = [
            "-c:v",
            "copy",
            "-c:a",
            "copy",
            "-sn",
            "-dn",
            "-map",
            "0:v:0",
            "-map",
            "0:a:0?",
            "-max_muxing_queue_size",
            "1024",  # R√©duit pour moins de latence
            "-fps_mode",
            "passthrough",
            "-fflags",
            "+genpts+igndts+discardcorrupt+autobsf",
            "-thread_queue_size",
            "1024",  # R√©duit pour moins de latence
            "-avoid_negative_ts",
            "make_zero",
        ]

        # Si on d√©tecte un fichier MKV, on ajuste les param√®tres
        if has_mkv:
            logger.info(
                f"[{self.channel_name}] ‚ö†Ô∏è Fichier MKV d√©tect√©, ajustement des param√®tres"
            )
            # Pour les MKV on peut avoir besoin de sp√©cifier explicitement certains param√®tres
            params = [
                "-c:v",
                "copy",
                "-c:a",
                "aac",  # Conversion audio en AAC pour compatibilit√©
                "-b:a",
                "192k",
                "-sn",
                "-dn",
                "-map",
                "0:v:0",
                "-map",
                "0:a:0?",
                "-max_muxing_queue_size",
                "4096",  # Buffer plus grand pour MKV
                "-fps_mode",
                "passthrough",
                "-fflags",
                "+genpts+igndts+discardcorrupt",
                "-thread_queue_size",
                "16384",  # Queue size encore plus grande pour MKV
                "-avoid_negative_ts",
                "make_zero",
            ]

        return params

    def build_fallback_command(self, input_file, output_dir):
        """
        # Construit une commande minimale en cas d'erreur
        """
        logger.warning(f"[{self.channel_name}] ‚ö†Ô∏è Utilisation de la commande de secours")
        return [
            "ffmpeg",
            "-hide_banner",
            "-loglevel",
            FFMPEG_LOG_LEVEL,
            "-y",
            "-re",
            "-i",
            str(input_file),
            "-c",
            "copy",
            "-f",
            "hls",
            "-hls_time",
            "6",
            "-hls_list_size",
            "5",
            "-hls_flags",
            "delete_segments",
            "-hls_segment_filename",
            f"{output_dir}/segment_%d.ts",
            f"{output_dir}/playlist.m3u8",
        ]

    def detect_mkv_in_playlist(self, playlist_file):
        """
        # D√©tecte si la playlist contient des fichiers MKV
        """
        try:
            if not Path(playlist_file).exists():
                return False

            with open(playlist_file, "r") as f:
                content = f.read()
                return ".mkv" in content.lower()

        except Exception as e:
            logger.error(f"[{self.channel_name}] ‚ùå Erreur d√©tection MKV: {e}")
            return False

    def optimize_for_hardware(self):
        """
        # Optimise les param√®tres pour le hardware disponible avec meilleure d√©tection
        """
        try:
            # D√©tection VAAPI plus robuste
            if self.use_gpu:
                # Essai direct de VAAPI
                test_cmd = [
                    "ffmpeg",
                    "-hide_banner",
                    "-loglevel",
                    "error",
                    "-hwaccel",
                    "vaapi",
                    "-hwaccel_output_format",
                    "vaapi",
                    "-vaapi_device",
                    "/dev/dri/renderD128",
                    "-f",
                    "lavfi",
                    "-i",
                    "color=black:s=1280x720",
                    "-vf",
                    "format=nv12|vaapi,hwupload",
                    "-c:v",
                    "h264_vaapi",
                    "-t",
                    "0.1",
                    "-f",
                    "null",
                    "-",
                ]
                result = subprocess.run(test_cmd, capture_output=True, text=True)

                if result.returncode == 0:
                    logger.info(f"[{self.channel_name}] ‚úÖ Support VAAPI v√©rifi√©")
                    # On peut utiliser VAAPI
                    return True
                else:
                    logger.warning(
                        f"[{self.channel_name}] ‚ö†Ô∏è Test VAAPI √©chou√©: {result.stderr}"
                    )
                    self.use_gpu = False
                    logger.info(f"[{self.channel_name}] üîÑ Basculement en mode CPU")

            # D√©tection des capacit√©s CPU
            cpu_count = os.cpu_count() or 4
            if cpu_count <= 2:
                # Ajustements pour CPU faible
                logger.info(
                    f"[{self.channel_name}] ‚ö†Ô∏è CPU limit√© ({cpu_count} c≈ìurs), ajustement des param√®tres"
                )
                self.hls_time = 4  # Segments plus longs
                self.video_bitrate = "3M"  # Bitrate plus faible

            return True

        except Exception as e:
            logger.error(f"[{self.channel_name}] ‚ùå Erreur optimisation hardware: {e}")
            # En cas d'erreur, on d√©sactive VAAPI
            self.use_gpu = False
            return False
