from pathlib import Path
import os
import time
from typing import Callable, Dict, Optional, Set, List
from config import logger, HLS_SEGMENT_DURATION, HLS_DIR
from log_utils import parse_access_log

class ClientMonitor:
    """
    Moniteur de clients ultra-simplifi√© qui lit access.log et met √† jour les stats.
    
    Version sans thread, sans lock, sans complexit√© inutile.
    """

    def __init__(self, log_path, update_watchers_callback, manager, stats_collector=None):
        """
        Initialise le moniteur ultra-simplifi√©.
        
        Args:
            log_path: Chemin vers access.log
            update_watchers_callback: Callback simple pour IPTVManager
            manager: R√©f√©rence vers IPTVManager (pour segment_duration)
            stats_collector: R√©f√©rence vers StatsCollector pour les stats
        """
        self.log_path = log_path
        self.update_watchers = update_watchers_callback
        self.manager = manager
        self.stats_collector = stats_collector
        
        # Position dans le fichier de log
        self.last_position = 0
        
        # Dictionnaire simple {ip: channel} pour d√©tecter les changements de cha√Æne
        self.viewers = {}
        
        # Intervalle entre mises √† jour du statut
        self.update_interval = 1.5
        
        # √âtat d'arr√™t
        self.should_stop = False
        
        logger.info("üîç ClientMonitor ultra-simplifi√© initialis√©")

    def start(self):
        """D√©marre le moniteur (non-bloquant)"""
        # Au lieu d'utiliser un thread, on initialise juste la position de lecture
        log_path_obj = Path(self.log_path)
        if log_path_obj.exists():
            with open(self.log_path, "r") as f:
                # Se positionner √† la fin du fichier
                f.seek(0, 2)
                self.last_position = f.tell()
                logger.info(f"üìù Positionnement initial √† la fin du fichier: {self.last_position} bytes")

        logger.info("üöÄ ClientMonitor d√©marr√© - Pour une mise √† jour, appelez process_new_logs()")

    def process_new_logs(self):
        """
        Traite les nouvelles lignes du fichier de log.
        Cette m√©thode doit √™tre appel√©e r√©guli√®rement par la boucle principale.
        
        Returns:
            bool: True si de nouvelles lignes ont √©t√© trait√©es
        """
        log_path_obj = Path(self.log_path)
        has_new_lines = False
        current_viewers = {}  # Pour collecter les viewers actifs
            
        try:
            # V√©rifier que le fichier existe
            if not log_path_obj.exists():
                return False
            
            # Lire les nouvelles lignes
            with open(self.log_path, "r", encoding="utf-8", errors="ignore") as file:
                # V√©rifier si le fichier a √©t√© recr√©√© (nouveau inode)
                if hasattr(self, "_last_inode") and self._last_inode != os.stat(self.log_path).st_ino:
                    logger.info("üîÑ Nouveau fichier de log d√©tect√©, r√©initialisation")
                    file.seek(0, 2)  # Aller √† la fin
                    self.last_position = file.tell()
                    self._last_inode = os.stat(self.log_path).st_ino
                    return False
                
                # Stocker l'inode pour la prochaine fois
                self._last_inode = os.stat(self.log_path).st_ino
                
                # Se positionner au dernier point de lecture
                file.seek(self.last_position)
                
                # Lire les nouvelles lignes
                new_lines = file.readlines()
                if new_lines:
                    has_new_lines = True
                
                # Mettre √† jour la position
                self.last_position = file.tell()
                
                # Traiter chaque ligne
                for line in new_lines:
                    self._process_line(line.strip(), current_viewers)
        
        except Exception as e:
            logger.error(f"‚ùå Erreur lecture access.log: {e}", exc_info=True)
            return False
            
        # Si des lignes ont √©t√© trait√©es, mettre √† jour les statuts
        if has_new_lines and self.update_watchers:
            self._update_channel_viewers(current_viewers)
            
        return has_new_lines

    def _process_line(self, line, current_viewers):
        """
        Traite une ligne de log et met √† jour les statistiques.
        Version ULTRA-SIMPLIFI√âE et CENTRALIS√âE qui ne traite QUE les segments.
        
        Args:
            line: Ligne de log √† traiter
            current_viewers: Dictionnaire {channel: set(ips)} √† mettre √† jour
        """
        # PREMI√àRE V√âRIFICATION ULTRA-RAPIDE: seulement segments .ts avec code 200
        if " 200 " not in line or ".ts" not in line or "segment" not in line:
            return
        
        # LOG EXPLICITE DES SEGMENTS RENCONTR√âS
        logger.info(f"üß† SEGMENT D√âTECT√â: {line}")
            
        # Toute la logique de parsing est dans parse_access_log
        # Cette fonction va appliquer tous les filtres n√©cessaires
        ip, channel, request_type, is_valid, path, user_agent = parse_access_log(line)
        
        # Si parse_access_log a rejet√© la ligne, on arr√™te l√†
        if not is_valid or not channel:
            logger.info(f"‚ùå SEGMENT REJET√â apr√®s parsing: {channel} (valide: {is_valid})")
            return
            
        logger.info(f"‚úÖ SEGMENT ACCEPT√â: {channel} demand√© par {ip}")
            
        # V√©rifier que c'est un canal valide
        if not self._is_channel_valid(channel):
            logger.info(f"‚ö†Ô∏è Canal invalide: {channel}")
            return
            
        # M√©moriser l'IP pour ce canal
        if channel not in current_viewers:
            current_viewers[channel] = set()
        current_viewers[channel].add(ip)
            
        # Monitorer les changements de cha√Æne
        previous_channel = self.viewers.get(ip)
        
        # SI CHANGEMENT DE CHA√éNE: g√©rer le changement
        if previous_channel != channel:
            # Log explicite du changement pour prouver la d√©tection
            logger.warning(f"ZAP! Channel change detected. IP: {ip}, From: {previous_channel}, To: {channel}")
            
            # Mise √† jour stats
            if previous_channel and self.stats_collector:
                self.stats_collector.handle_channel_change(ip, previous_channel, channel)
                
            # Retirer l'IP de l'ancienne cha√Æne dans current_viewers
            if previous_channel and previous_channel in current_viewers:
                current_viewers[previous_channel].discard(ip)
                # Si la cha√Æne n'a plus de spectateurs, la retirer
                if not current_viewers[previous_channel]:
                    del current_viewers[previous_channel]
                
            # Mettre √† jour le canal actuel
            self.viewers[ip] = channel
            
            # Notifications imm√©diates
            if self.update_watchers:
                # Force la mise √† jour pour la nouvelle cha√Æne
                self._notify_channel_immediately(channel, ip)
                # Et retire le spectateur de l'ancienne
                if previous_channel:
                    self._notify_channel_immediately(previous_channel, ip, remove=True)
                    
            # NETTOYAGE COMPLET pour √©viter le "collage"
            logger.info(f"üßπ NETTOYAGE COMPLET des viewers apr√®s changement {previous_channel} ‚Üí {channel}")
            # Vider tous les viewers sauf pour le canal actuel
            for ch in list(current_viewers.keys()):
                if ch != channel:
                    current_viewers[ch].discard(ip)
                    # Supprimer les cha√Ænes sans spectateurs
                    if not current_viewers[ch]:
                        del current_viewers[ch]
            
            # S'assurer que l'IP est bien dans la nouvelle cha√Æne
            if channel not in current_viewers:
                current_viewers[channel] = set()
            current_viewers[channel].add(ip)
            
            # Force update imm√©diat
            self._update_channel_viewers(current_viewers)
            
            # Log confirmant la mise √† jour
            logger.info(f"‚úì Changement {previous_channel} ‚Üí {channel} trait√© avec succ√®s")
        
        # SI PAS DE CHANGEMENT: mise √† jour simple et statistiques
        else:
            # Utiliser HLS_SEGMENT_DURATION pour la synchronisation
            segment_update_interval = float(os.getenv("HLS_SEGMENT_DURATION", "2.0"))
            last_update_key = f"_last_segment_update_{channel}_{ip}"
            current_time = time.time()
            last_update_time = getattr(self, last_update_key, 0)
            
            if current_time - last_update_time > segment_update_interval:
                # Mise √† jour avec log explicite
                logger.debug(f"‚è±Ô∏è Mise √† jour synchronis√©e pour {channel} (spectateur: {ip})")
                self._notify_channel_immediately(channel, ip)
                setattr(self, last_update_key, current_time)
        
        # Mise √† jour des stats
        if self.stats_collector:
            # Dur√©e par d√©faut depuis l'environnement
            segment_duration = float(os.getenv("HLS_SEGMENT_DURATION", "2.0"))
            
            # Tenter d'obtenir la dur√©e sp√©cifique de ce canal
            try:
                duration = self.manager.get_channel_segment_duration(channel)
                if duration and duration > 0:
                    segment_duration = duration
            except:
                pass
            
            # Enregistrer l'activit√© avec la dur√©e exacte du segment
            self.stats_collector._record_log_activity(ip, channel, user_agent, 0)
            logger.debug(f"‚è±Ô∏è Stats mises √† jour pour {channel}: +{segment_duration:.1f}s")

    def _is_channel_valid(self, channel):
        """
        V√©rifie simplement si un canal existe dans le manager.
        Version simplifi√©e sans v√©rifications complexes.
        """
        return hasattr(self.manager, "channels") and channel in self.manager.channels
        
    def _update_channel_viewers(self, current_viewers):
        """
        Met √† jour le statut de toutes les cha√Ænes via le callback.
        Version am√©lior√©e pour une d√©tection plus fiable des spectateurs actifs.
        """
        # Obtenir toutes les cha√Ænes connues
        all_channels = set(self.manager.channels.keys()) if hasattr(self.manager, "channels") else set()
        
        # V√©rifier la coh√©rence des viewers
        # Un spectateur ne peut √™tre que sur une seule cha√Æne √† la fois
        seen_ips = {}  # {ip: channel}
        for channel, viewers in current_viewers.items():
            for ip in list(viewers):  # Convertir en liste pour pouvoir modifier pendant l'it√©ration
                if ip in seen_ips:
                    # L'IP est d√©j√† vue sur une autre cha√Æne
                    old_channel = seen_ips[ip]
                    # Garder l'IP uniquement sur la cha√Æne la plus r√©cente selon self.viewers
                    current_channel = self.viewers.get(ip)
                    if current_channel == channel:
                        # Retirer l'IP de l'ancienne cha√Æne
                        current_viewers[old_channel].discard(ip)
                        if not current_viewers[old_channel]:
                            del current_viewers[old_channel]
                        seen_ips[ip] = channel
                        logger.info(f"üîÑ {ip} retir√© de {old_channel} (actif sur {channel})")
                    else:
                        # Retirer l'IP de cette cha√Æne
                        viewers.discard(ip)
                        if not viewers:
                            del current_viewers[channel]
                        logger.info(f"üîÑ {ip} retir√© de {channel} (actif sur {old_channel})")
                else:
                    seen_ips[ip] = channel
        
        # Mettre √† jour TOUTES les cha√Ænes, pas seulement celles avec des spectateurs
        for channel in all_channels:
            if channel == "master_playlist":
                continue
                
            # Obtenir les viewers actuels pour cette cha√Æne
            viewers = list(current_viewers.get(channel, set()))
            
            # V√©rifier self.viewers pour s'assurer que les spectateurs sont toujours actifs
            # Un spectateur n'est consid√©r√© actif que sur sa cha√Æne actuelle
            active_viewers = []
            for ip in viewers:
                if self.viewers.get(ip) == channel:
                    active_viewers.append(ip)
                else:
                    logger.debug(f"[{channel}] ‚ö†Ô∏è {ip} ignor√© (actif sur {self.viewers.get(ip)})")
            
            # Compteur de spectateurs apr√®s l'ajout des viewers manquants
            count = len(active_viewers)
            
            # Mise √† jour via callback avec log plus d√©taill√©
            if count > 0:
                logger.info(f"[{channel}] üëÅÔ∏è Mise √† jour p√©riodique: {count} spectateurs actifs")
            else:
                # Log de niveau debug pour les canaux sans spectateurs
                logger.debug(f"[{channel}] Mise √† jour p√©riodique: 0 spectateurs")
            
            # TOUJOURS envoyer la mise √† jour, m√™me quand count = 0
            # C'est crucial pour maintenir l'√©tat coh√©rent des cha√Ænes sans spectateurs
            self.update_watchers(channel, count, active_viewers, HLS_DIR, source="nginx_log")

    def _notify_channel_immediately(self, channel, ip, remove=False):
        """
        Notifie imm√©diatement un changement pour un canal.
        Version am√©lior√©e et plus robuste.
        """
        if not self.update_watchers:
            return
            
        # Collecter tous les IPs actuels pour ce canal
        viewers = [ip2 for ip2, ch in self.viewers.items() if ch == channel]
        
        # Si on veut retirer l'IP
        if remove and ip in viewers:
            viewers.remove(ip)
            # Retirer aussi l'IP du dictionnaire des viewers
            if ip in self.viewers and self.viewers[ip] == channel:
                del self.viewers[ip]
            logger.info(f"[{channel}] üö´ Retrait explicite de {ip}")
        # Si on veut ajouter l'IP et qu'elle n'est pas d√©j√† pr√©sente
        elif not remove and ip not in viewers:
            viewers.append(ip)
            # Mettre √† jour le dictionnaire des viewers
            # Si l'IP √©tait sur une autre cha√Æne, la retirer d'abord
            old_channel = self.viewers.get(ip)
            if old_channel and old_channel != channel:
                # Forcer une notification de retrait sur l'ancienne cha√Æne
                self._notify_channel_immediately(old_channel, ip, remove=True)
                logger.info(f"[{old_channel}] üîÑ Retrait forc√© de {ip} (changement vers {channel})")
            self.viewers[ip] = channel
            
        # Notification TOUJOURS, m√™me sans viewers pour mettre √† jour correctement l'√©tat
        # C'est crucial pour les channels sans spectateurs ou quand on en retire
        self.update_watchers(channel, len(viewers), viewers, HLS_DIR, source="nginx_log_immediate")
        
        # Log plus d√©taill√©
        if remove:
            logger.info(f"[{channel}] üëÅÔ∏è Notification imm√©diate (retrait): {len(viewers)} spectateurs actifs")
        else:
            logger.info(f"[{channel}] üëÅÔ∏è Notification imm√©diate (ajout/mise √† jour): {len(viewers)} spectateurs actifs")

    def stop(self):
        """Arr√™te proprement le moniteur"""
        self.should_stop = True
        logger.info("üõë ClientMonitor arr√™t√©")